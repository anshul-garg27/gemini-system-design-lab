{
  "meta": {
    "topic_id": "1727",
    "topic_title": "How infrastructure as code deploys entire systems with one command",
    "platform": "devto",
    "format": "article",
    "content_schema_version": "v1.0.0",
    "model_version": "gemini-2.5-flash",
    "prompt_version": "devto-article-1.2",
    "audience": "intermediate",
    "tone": "clear, confident, non-cringe",
    "locale": "en",
    "primary_keywords": [
      "infrastructure as code",
      "iac",
      "terraform",
      "deploy systems"
    ],
    "secondary_keywords": [
      "devops automation",
      "cloud infrastructure",
      "declarative infrastructure",
      "terraform apply"
    ],
    "lsi_terms": [
      "version control",
      "state file",
      "repeatable deployment",
      "cloudformation",
      "pulumi",
      "ansible",
      "immutable infrastructure"
    ],
    "canonical": "https://example.com/topic/1727",
    "brand": {
      "site_url": "https://example.com/topic/1727",
      "handles": {
        "x": "@systemdesign",
        "linkedin": "@systemdesign",
        "github": "@systemdesign"
      },
      "utm_base": "utm_source=devto&utm_medium=article"
    },
    "options": {
      "include_images": true,
      "max_length_levels": "standard",
      "variance_seed": "default"
    },
    "keyword_overrides": false,
    "keyword_tiers": {
      "broad": [
        "devops",
        "cloud"
      ],
      "niche": [
        "iac",
        "terraform"
      ],
      "micro_niche": []
    },
    "image_plan": {
      "count": 1,
      "roles": [
        "cover"
      ],
      "ratios_px": [
        {
          "ratio": "1.91:1",
          "size_px": "1200x630"
        }
      ]
    }
  },
  "content": {
    "front_matter": {
      "title": "Deploy Your Entire System with One Command: A Guide to IaC",
      "published": true,
      "tags": [
        "devops",
        "cloud",
        "iac",
        "terraform"
      ],
      "cover_image": "https://example.com/images/devto/1727-cover.png",
      "canonical_url": "https://example.com/topic/1727"
    },
    "markdown": "---\ntitle: Deploy Your Entire System with One Command: A Guide to IaC\npublished: true\ntags: devops, cloud, iac, terraform\ncover_image: https://example.com/images/devto/1727-cover.png\ncanonical_url: https://example.com/topic/1727\n---\n\nRemember the last time you had to manually provision a server? Clicking through a web console, setting up networking, configuring security groups... it's slow, tedious, and a perfect recipe for human error. This manual toil is a major drag on productivity—teams without automation can spend up to 30% of their engineering time on configuration and fixes.\n\nInfrastructure as Code (IaC) is the definitive solution to this problem. It allows you to manage and provision your entire IT infrastructure using code, just like you do with your applications.\n\n### What Exactly is Infrastructure as Code?\n\nIaC is the practice of defining your infrastructure—servers, databases, networks, load balancers—in machine-readable files. Instead of manually configuring resources, you write code that specifies your desired setup. This brings the power of software development—version control, code review, and automated testing—to your infrastructure.\n\nThere are two main approaches:\n\n*   **Declarative (The \"What\"):** You define the desired *end state* of your system. For example, \"I want one virtual server with these specs and this software installed.\" The IaC tool figures out how to make it happen. This is the dominant approach used by tools like Terraform, Pulumi, and AWS CloudFormation.\n*   **Imperative (The \"How\"):** You write scripts that execute a sequence of commands to reach the desired state. For example, \"Create a server, then install this package, then start this service.\" This is common in custom shell scripts or tools like Ansible.\n\nWe'll focus on the declarative approach, as it's more robust for managing complex system states.\n\n### The Core IaC Workflow: Write, Plan, Apply\n\nThe declarative IaC process is a simple but powerful three-step loop. It ensures that every change is predictable and intentional.\n\n1.  **Write:** You define your infrastructure components in configuration files using a specific syntax (like HCL for Terraform).\n2.  **Plan:** The IaC tool analyzes your code and compares it to the current state of your live infrastructure. It then generates an execution plan detailing exactly what it will create, update, or delete. This step is your safety net—a dry run to prevent costly mistakes.\n3.  **Apply:** Once you review and approve the plan, the tool executes the necessary actions to bring your infrastructure to the desired state defined in your code.\n\nThis workflow makes infrastructure changes transparent and auditable.\n\n```mermaid\ngraph TD\n    A[1. Write Code <br> (main.tf)] --> B{IaC Tool <br> (Terraform)};\n    B --> C[2. Plan <br> (terraform plan)];\n    C --> D{Review Execution Plan};    D -- Approve --> E[3. Apply <br> (terraform apply)];\n    D -- Reject --> A;\n    E --> F[Cloud Infrastructure <br> (AWS, GCP, Azure)];\n```\n_**Alt text:** A flowchart showing the IaC workflow: Write Code, which goes to the IaC Tool. The tool generates a Plan for review. If approved, the tool Applies the changes to the Cloud Infrastructure. If rejected, the user goes back to writing code._\n\n### Hands-On: Deploy a Web Server with Terraform\n\nLet's build something. We'll use Terraform to deploy a simple Nginx web server on an AWS EC2 instance. You'll need an AWS account, the AWS CLI configured, and Terraform installed.\n\n**Step 1: Set up your project**\n\nCreate a directory for your project and a configuration file.\n\n```bash\nmkdir iac-demo && cd iac-demo\ntouch main.tf\n```\n\n**Step 2: Define your infrastructure**\n\nPaste the following code into your `main.tf` file. This configuration tells Terraform to use the AWS provider, find the default network (VPC), create a security group to allow web and SSH traffic, and launch a small EC2 server that installs Nginx on startup.\n\n```hcl\nterraform {\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 5.0\"\n    }\n  }\n}\n\nprovider \"aws\" {\n  region = \"us-east-1\"\n}\n\n# Find the latest Ubuntu AMI\ndata \"aws_ami\" \"ubuntu\" {\n  most_recent = true\n  filter {\n    name   = \"name\"\n    values = [\"ubuntu/images/hvm-ssd/ubuntu-jammy-22.04-amd64-server-*\"]\n  }\n  filter {\n    name   = \"virtualization-type\"\n    values = [\"hvm\"]\n  }\n  owners = [\"099720109477\"] # Canonical\n}\n\n# Get the default VPC for our account\ndata \"aws_vpc\" \"default\" {\n  default = true\n}\n\n# Create a security group to allow HTTP and SSH\nresource \"aws_security_group\" \"web_sg\" {\n  name        = \"web-server-sg\"\n  description = \"Allow HTTP and SSH inbound traffic\"\n  vpc_id      = data.aws_vpc.default.id\n\n  ingress {\n    from_port   = 80\n    to_port     = 80\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  ingress {\n    from_port   = 22\n    to_port     = 22\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}\n\n# Launch an EC2 instance\nresource \"aws_instance\" \"web_server\" {\n  ami           = data.aws_ami.ubuntu.id\n  instance_type = \"t2.micro\"\n  vpc_security_group_ids = [aws_security_group.web_sg.id]\n\n  # A simple script to install and start Nginx\n  user_data = <<-EOF\n              #!/bin/bash\n              sudo apt-get update\n              sudo apt-get install -y nginx\n              sudo systemctl start nginx\n              EOF\n\n  tags = {\n    Name = \"ExampleWebServer\"\n  }\n}\n\n# Output the public IP of the server\noutput \"instance_public_ip\" {\n  value = aws_instance.web_server.public_ip\n}\n```\n\n**Step 3: Deploy with one command**\n\nNow, run the core Terraform commands. `init` downloads the necessary provider plugins. `plan` shows you what will be created. `apply` builds the infrastructure.\n\n```bash\n# Initialize the project\nterraform init\n\n# (Optional) See the execution plan\nterraform plan\n\n# Apply the configuration to create the resources\nterraform apply --auto-approve\n```\n\nAfter a minute or two, Terraform will output the public IP address of your new server. Paste that IP into your browser, and you'll see the default Nginx welcome page!\n\nTo clean up, simply run `terraform destroy --auto-approve`.\n\n### Trade-offs and Considerations\n\nIaC is incredibly powerful, but it's not magic. Here are the key trade-offs:\n\n*   **Pro: Version Control & Auditing.** Your infrastructure lives in Git. Every change is reviewed, tracked, and revertible, providing a complete audit trail.\n*   **Pro: Repeatability & Consistency.** You can spin up an identical copy of your production environment for staging or testing in minutes, eliminating \"it works on my machine\" issues.\n*   **Con: State Management Complexity.** Terraform uses a `state file` to track your resources. This file is critical and must be stored securely and reliably, typically in a remote backend like an S3 bucket.\n*   **Con: Large Blast Radius.** A mistake in your code can have major consequences, like deleting your production database. The `terraform plan` step is your most important safeguard. Always review it carefully!\n\n### Final Thoughts\n\nInfrastructure as Code is a fundamental pillar of modern DevOps and cloud engineering. It transforms infrastructure management from a manual, error-prone task into a repeatable, automated, and scalable software engineering discipline. By treating your infrastructure like an application, you unlock speed, reliability, and consistency across your entire development lifecycle.\n\nThis was a high-level overview. For a deeper dive into state management, modules, and advanced patterns, check out the full breakdown on our site: https://example.com/topic/1727?utm_source=devto&utm_medium=article\n",
    "reading_time_min": 7,
    "code_snippets": [
      {
        "language": "bash",
        "label": "Project Setup",
        "content": "```bash\nmkdir iac-demo && cd iac-demo\ntouch main.tf\n```",
        "runnable": true
      },
      {
        "language": "hcl",
        "label": "Terraform Configuration (main.tf)",
        "content": "```hcl\nterraform {\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 5.0\"\n    }\n  }\n}\n\nprovider \"aws\" {\n  region = \"us-east-1\"\n}\n\n# Find the latest Ubuntu AMI\ndata \"aws_ami\" \"ubuntu\" {\n  most_recent = true\n  filter {\n    name   = \"name\"\n    values = [\"ubuntu/images/hvm-ssd/ubuntu-jammy-22.04-amd64-server-*\"]\n  }\n  filter {\n    name   = \"virtualization-type\"\n    values = [\"hvm\"]\n  }\n  owners = [\"099720109477\"] # Canonical\n}\n\n# Get the default VPC for our account\ndata \"aws_vpc\" \"default\" {\n  default = true\n}\n\n# Create a security group to allow HTTP and SSH\nresource \"aws_security_group\" \"web_sg\" {\n  name        = \"web-server-sg\"\n  description = \"Allow HTTP and SSH inbound traffic\"\n  vpc_id      = data.aws_vpc.default.id\n\n  ingress {\n    from_port   = 80\n    to_port     = 80\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  ingress {\n    from_port   = 22\n    to_port     = 22\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}\n\n# Launch an EC2 instance\nresource \"aws_instance\" \"web_server\" {\n  ami           = data.aws_ami.ubuntu.id\n  instance_type = \"t2.micro\"\n  vpc_security_group_ids = [aws_security_group.web_sg.id]\n\n  # A simple script to install and start Nginx\n  user_data = <<-EOF\n              #!/bin/bash\n              sudo apt-get update\n              sudo apt-get install -y nginx\n              sudo systemctl start nginx\n              EOF\n\n  tags = {\n    Name = \"ExampleWebServer\"\n  }\n}\n\n# Output the public IP of the server\noutput \"instance_public_ip\" {\n  value = aws_instance.web_server.public_ip\n}\n```",
        "runnable": true
      },
      {
        "language": "bash",
        "label": "Deploy and Destroy",
        "content": "```bash\n# Initialize the project\nterraform init\n\n# (Optional) See the execution plan\nterraform plan\n\n# Apply the configuration to create the resources\nterraform apply --auto-approve\n\n# To destroy all resources when you're done:\n# terraform destroy --auto-approve\n```",
        "runnable": true
      }
    ],
    "diagram_blocks": [
      {
        "id": "d1",
        "type": "mermaid",
        "alt": "A flowchart showing the IaC workflow: Write Code, which goes to the IaC Tool. The tool generates a Plan for review. If approved, the tool Applies the changes to the Cloud Infrastructure. If rejected, the user goes back to writing code.",
        "content": "graph TD\n    A[1. Write Code <br> (main.tf)] --> B{IaC Tool <br> (Terraform)};\n    B --> C[2. Plan <br> (terraform plan)];\n    C --> D{Review Execution Plan};\n    D -- Approve --> E[3. Apply <br> (terraform apply)];\n    D -- Reject --> A;\n    E --> F[Cloud Infrastructure <br> (AWS, GCP, Azure)];",
        "placement_hint": "After 'The Core IaC Workflow' section"
      }
    ],
    "resources": [
      {
        "title": "Terraform Documentation",
        "url": "https://developer.hashicorp.com/terraform/docs",
        "note": "Official documentation for HashiCorp Terraform."
      },
      {
        "title": "Pulumi - IaC in your favorite language",
        "url": "https://www.pulumi.com/",
        "note": "An alternative IaC tool that uses general-purpose programming languages."
      }
    ]
  },
  "image_prompts": [
    {
      "role": "cover",
      "title": "Dev.to Cover",
      "prompt": "Widescreen minimal cover for \"Infrastructure as Code: One Command Deployments\". Clean typographic title top-left; a small, abstract glyph showing code brackets transforming into cloud shapes to the right; off-white background; thin vector strokes; subtle dotted grid; one restrained accent color (e.g., a calm blue); generous margins; flat vector; export crisp 1200×630.",
      "negative_prompt": "no stock-photo people, no logos, no neon, no 3D bevels, no glossy gradients, no clutter",
      "style_notes": "editorial poster tone; crisp kerning; consistent stroke widths",
      "ratio": "1.91:1",
      "size_px": "1200x630",
      "alt_text": "Cover image for Infrastructure as Code article, showing title and a glyph of code becoming cloud infrastructure."
    }
  ],
  "seo": {
    "keywords_used": [
      "infrastructure as code",
      "iac",
      "terraform",
      "devops automation",
      "cloud infrastructure",
      "declarative infrastructure",
      "terraform apply"
    ],
    "lsi_terms_used": [
      "version control",
      "state file",
      "repeatable deployment",
      "pulumi",
      "ansible"
    ]
  },
  "compliance": {
    "word_count": 1218,
    "code_snippets_count": 3,
    "diagram_blocks_count": 1,
    "tags_count": 4,
    "has_cover_image": true,
    "image_prompt_count": 1,
    "has_tracked_link_once": true,
    "keyword_overrides": false,
    "checks": [
      "1000–2500 words",
      "≥2 runnable code snippets with language fences",
      "≥1 diagram block (mermaid/ascii) with alt text",
      "≤4 tags, lowercase, topic-appropriate",
      "front_matter.cover_image is a full URL",
      "exactly one tracked link if primary_url present",
      "image_prompts length == image_plan.count (default 1)"
    ]
  }
}